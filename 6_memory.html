<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory-Allocation</title>
</head>
<body>
    <h1>Memory Allocation in JavaScript</h1>
    <p>
        In JavaScript, memory allocation is managed automatically through a process called garbage collection. 
        When you create variables, objects, or functions, memory is allocated to store these values. 
        JavaScript uses a combination of stack and heap memory to manage data.
    </p>
    <h2>Stack Memory("Provide actual copy")</h2>
    <p>
        Stack memory is used for storing primitive data types (like numbers, strings, booleans) and function calls. 
        It operates in a last-in-first-out (LIFO) manner, meaning the last item added to the stack is the first one to be removed. 
        Stack memory is fast and efficient but has a limited size.
    </p>
    <h2>Heap Memory("Provide reference(actual value)")</h2>
    <p>
        Heap memory is used for storing non-primitive data types (like objects and arrays). 
        It allows for dynamic memory allocation, meaning that memory can be allocated and deallocated as needed. 
        Heap memory is larger than stack memory but is slower to access.
    </p>
    <h2>Garbage Collection</h2>
    <p>
        JavaScript automatically manages memory through garbage collection. 
        When an object or variable is no longer referenced or accessible in the code, the garbage collector identifies it as "garbage" and frees up the memory it occupied. 
        This helps prevent memory leaks and ensures efficient use of memory resources.
    </p>
    <h2>Best Practices for Memory Management</h2>
    <ul>
        <li>Avoid creating unnecessary global variables.</li>
        <li>Use local variables whenever possible.</li>
        <li>Set unused objects or variables to null to help the garbage collector identify them.</li>
        <li>Avoid circular references between objects.</li>
        <li>Be cautious with large data structures and clean them up when they are no longer needed.</li>
    </ul>
    <p>
        By understanding how memory allocation works in JavaScript and following best practices, you can write efficient and effective code that makes optimal use of memory resources.
    </p>

    <img src="./Image/stack-heap-pointers.png" alt="Memory Allocation in JavaScript (Stack and Heap Memory)" style="width:1200px;height:600px;">
    
    <p>
        Example: <br><br></b>
        let name = "Alice"; // Memory allocated in stack <br>
        let anotherName = name; // Both variables point to the same string in stack memory <br>

        console.log(name); // "Alice" <br>
        console.log(anotherName); // "Alice" <br><br>

        name = "Bob"; // 'name' now points to a new string in stack memory <br>

        console.log(name); // "Bob" <br>
        console.log(anotherName); // "Alice" (remains unchanged) <br><br>

        let obj1 = { key: "value" }; // Memory allocated in heap <br>
        let obj2 = obj1; // Both variables reference the same object in heap memory <br>

        console.log(obj1); // { key: "value" } <br>
        console.log(obj2); // { key: "value" } <br><br>

        obj1.key = "newValue"; // Modifying the object through obj1 <br>
        console.log(obj1); // { key: "newValue" } <br>
        console.log(obj2); // { key: "newValue" } (reflects the change)
    </p>

    <script>
        // You can run the above code snippets in the browser console to see the results.
        let name = "Alice";
        let anotherName = name; // Both variables point to the same string in stack memory
        console.log(name); // "Alice"
        console.log(anotherName); // "Alice"

        name = "Bob"; // 'name' now points to a new string in stack memory
        console.log(name); // "Bob"
        console.log(anotherName); // "Alice" (remains unchanged)

        let obj1 = { key: "value" }; // Memory allocated in heap
        let obj2 = obj1; // Both variables reference the same object in heap memory
        console.log(obj1); // { key: "value" }
        console.log(obj2); // { key: "value" }

        obj1.key = "newValue"; // Modifying the object through obj1
        console.log(obj1); // { key: "newValue" }
        console.log(obj2); // { key: "newValue" } (reflects the change)
    </script>
</body>
</html>